### JAVA内存模型

```markdown
在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享（本章用“共享变量”这个术语代指实例域，静态域和数组元素）。
局部变量（LocalVariables），方法定义参数（Java语言规范称之为FormalMethodParameters）和异常处理器参数（ExceptionHandlerParameters）
不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

方腾飞,魏鹏,程晓明. Java并发编程的艺术 (Java核心技术系列) (Chinese Edition) (p. 55). 机械工业出版社. Kindle Edition. 
```

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/202302131206011.png)

#### A-B线程通信

1. A把本地内存中更新过的共享变量刷新到主内存中
2. B到中内存中读取A之前已更新过的共享变量

#### 重排序类型

1. 编辑器重排序-在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级重排序-现代处理器采用了指令级并行技术（InstructionLevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统重排序-由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（MemoryBarriers，Intel称之为MemoryFence）指令，
**通过内存屏障指令来禁止特定类型的处理器重排序**。

#### 现代处理器操作内存

现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：
**处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致**
。由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写读操作进行重排序。

#### 内存屏障

JMM把内存屏障指令分为4类

方腾飞,魏鹏,程晓明. Java并发编程的艺术 (Java核心技术系列) (Chinese Edition) (p. 64). 机械工业出版社. Kindle Edition.
![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/202302131232161.png)

#### happens-before

从JDK5开始，Java使用新的JSR133内存模型，JSR133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，
**两个操作既可以是在一个线程之内，也可以是在不同线程之间**。

happens-before规则：

1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

**两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前
（the first is visible to and ordered before the second）。**

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/202302131239500.png)

#### as-if-serial语义

as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），**（单线程）程序**
的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。

为了遵守as-if-serial语义，编译器和处理器**不会对存在数据依赖关系的操作做重排序**
，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。
as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个
**幻觉：单线程程序是按程序的顺序来执行的**。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。

### 对并发重排序的理解

首先针对共享变量而言，各个cpu有自己的缓冲区，只有最终实现写内存中的变量之后该"写"
才会被其他cpu可见。根据背景，数据通过总线实现一系列步骤（总线事务）在cpu和内存中传递，而总线会同步试图并发使用总线的事务，把所有cpu对内存的访问以串行化的方式执行。
因此我认为多线程并发本质上是每个线程各自遵守"as-if-serial"
重排序，但由于cpu最终操作内存时还是串行的，因此没有正确同步的程序最终串行执行总的总线事务时由于重排序改变了程序语义，使结果不具有顺序一致性（即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。

顺序一致性内存模型

1. 一个线程中的所有操作必须按照程序的顺序来执行。
2. （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。
3. 在顺序一致性内存模型中，每个操作都必须**原子执行且立刻对所有线程可见**。

未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。
但在JMM中就没有这个保证，**未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致**。

换而言之，检查程序是否正确同步，核心就是检查程序是否具有顺序一致性。