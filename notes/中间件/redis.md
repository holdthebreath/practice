# Redis

## 基础

**Redis**采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的**QPS**
（每秒内查询次数）。

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于**HashMap**，**HashMap**
  的优势就是查找和操作的时间复杂度都是O(1)；
- 数据结构简单，对数据操作也简单，**Redis**中的数据结构是专门进行设计的；
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 **CPU**
  ，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路I/O复用模型，非阻塞IO；
- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，**Redis**直接自己构建了VM 机制
  ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

## 多路I/O复用模型，非阻塞IO原理

待补充

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518141832.webp)

## 数据结构

### String

在`Redis`中`String`是可以修改的，称为`动态字符串`(`Simple Dynamic String` 简称 `SDS`)
，说是字符串但它的内部结构更像是一个 `ArrayList`，内部维护着一个字节数组，并且在其内部预分配了一定的空间，以减少内存的频繁分配。

`Redis`的内存分配机制：

- 当字符串的长度小于1MB时，每次扩容都是加倍现有的空间。
- 如果字符串长度超过1MB时，每次扩容时只会扩展 1MB 的空间。

保证了内存空间够用，还不至于造成内存的浪费，**字符串最大长度为 `512MB`**。

![在这里插入图片描述](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518142320.png)

基本结构： `content` 里面保存的是字符串内容，`0x\0`作为结束字符不会被计算`len`中。

```c
struct SDS{
  T capacity;       //数组容量
  T len;            //实际长度
  byte flages;      //标志位,低三位表示类型
  byte[] content;   //数组内容
}
```

`capacity` 和 `len`两个属性都是泛型，为什么不直接用`int类型`？

因为`Redis`内部有很多优化方案，为更合理地使用内存，不同长度的字符串采用不同的数据类型表示，且在创建字符串的时候 `len`
会和 `capacity` 一样大，不产生冗余的空间，所以`String`值可以是字符串、数字（整数、浮点数) 或者 二进制。

#### 为什么要设计成SDS不用C的字符串

`redis`也支持使用`C`语言的传统字符串，只不过会用在一些不需要对字符串修改的地方，比如静态的字符输出。

而我们开发中使用`redis`，往往会经常性的修改字符串的值，这个时候就会用`SDS`来表示字符串的值了。**在redis数据库中，`key-value`
键值对含有字符串值的，都是由`SDS`来实现的**。

`SDS`没有完全直接使用`C`的字符串，还是沿用了一些C特性，比如遵循`C`
的字符串以空格符结尾的规则，这样还可以使用一部分C字符串的函数。而对于SDS来说，空字符串占用的一字节是不计算在`len`
属性里的，会为他分配额外的空间。

##### 效率高

![img](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518153312.png)

举个例子：工作中使用`redis`，经常会通过`STRLEN`命令得到一个字符串的长度，在`SDS`结构中`len`
属性记录了字符串的长度，所以我们获取一个字符串长度直接取`len`的值，复杂度是O(1)。

而如果用C字符串，在获取一个字符串长度时，需对整个字符串进行遍历，直至遍历到空格符结束（C中遇到空格符代表一个完整字符串），此时的复杂度是O(
N)。

在高并发场景下频繁遍历字符串，获取字符串的长度很有可能成为`redis`的性能瓶颈，所以SDS性能更好一些。

##### 数据溢出

上边提到C字符串是不记录自身长度的，相邻的两个字符串存储的方式可能如下图，为字符串分配了合适的内存空间。

![img](https://segmentfault.com/img/remote/1460000039237800)

如果此时我想把`“程序员内点事”`改成`“程序员内点事123”`，可之前分配的内存只有6个字节，修改后的字符串需要9个字节才能放下啊，怎么搞？

![img](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518154047.png)

没办法只能`侵占`相邻字符串的空间，自身数据溢出导致其他字符串的内容被修改。

而SDS很好的规避了这点，当需要**修改数据时，首先会检查当前SDS空间`len`
是否满足，不满足则自动扩容空间至修改所需的大小，然后再执行修改**,如下图所示。

![img](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518154103.png)

**不过有个特殊的地方**，在把`“程序员内点事”`的6个字节扩容到`“程序员内点事123”`9个字节后，发现`free`
属性的值变成了扩容后字符串的总长度，这就涉及到下边要说的内存重分配策略了。

##### 内存重分配策略

**
C字符串长度是一定的，所以每次在增长或者缩短字符串时，都要做内存的重分配，而内存重分配算法通常又是一个比较耗时的操作，如果程序不经常修改字符串还是可以接受的**
。

但很不幸，`redis`作为一个数据库，数据肯定会被频繁修改，如果每次修改都要执行一次内存重分配，那么就会严重影响性能。

SDS通过两种内存重分配策略，很好的解决了字符串在增长和缩短时的内存分配问题。

1. 空间预分配：空间预分配策略用于优化SDS**字符串增长**
   操作，当修改字符串并需对SDS的空间进行扩展时，不仅会为SDS分配修改所必要的空间，还会为SDS分配额外的未使用空间`free`
   ，下次再修改就先检查未使用空间`free`是否满足，满足则不用在扩展空间。

   通过空间预分配策略，`redis`可以有效的减少字符串连续增长操作，所产生的内存重分配次数。

   ![img](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518154340.png)

   额外分配未使用空间`free`的规则：

    - 如果对 SDS 字符串修改后，`len` 值小于 `1M`，那么此时额外分配未使用空间 `free` 的大小与`len`相等。

    - 如果对 SDS 字符串修改后，`len` 值大于等于 `1M`，那么此时额外分配未使用空间 `free` 的大小为`1M`。

2. 惰性空间释放

惰性空间释放策略则用于优化SDS**字符串缩短**操作，当缩短SDS字符串后，并不会立即执行内存重分配来回收多余的空间，而是用`free`
属性将这些空间记录下来，如果后续有增长操作，则可直接使用。

![img](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518155652.png)

##### 数据格式多样性

C字符串中的字符必须符合某些特定的编码格式，而且上边我们也提到，C字符串以`\0`
空字符结尾标识一个字符串结束，所以字符串里边是不能包含`\0`的，不然就会被误认是多个。

由于这种限制，使得C字符串只能保存文本数据，像音视频、图片等二进制格式的数据是无法存储的。

redis 会以处理二进制的方式操作`Buf`数组中的数据，所以对存入其中的数据做任何的限制、过滤，只要存进来什么样，取出来还是什么样。

#### 常用命令

```
set   [key]  [value]   给指定key设置值（set 可覆盖老的值）

get  [key]   获取指定key 的值

del  [key]   删除指定key

exists  [key]  判断是否存在指定key

mset  [key1]  [value1]  [key2]  [value2] ...... 批量存键值对

mget  [key1]  [key2] ......   批量取key

expire [key]  [time]    给指定key 设置过期时间  单位秒

setex    [key]  [time]  [value]  等价于 set + expire 命令组合

setnx  [key]  [value]   如果key不存在则set 创建，否则返回0

incr   [key]           如果value为整数 可用 incr命令每次自增1

incrby  [key] [number]  使用incrby命令对整数值 进行增加 number
```

### Hash

`Redis` 中的 `Hash`和 Java的 `HashMap` 更加相似，都是`数组+链表`的结构，当发生 hash
碰撞时将会把元素追加到链表上，值得注意的是在 `Redis` 的 `Hash` 中 `value` 只能是字符串。

#### 应用场景

- 购物车：`hset [key] [field] [value]` 命令， 可以实现以`用户Id`，`商品Id`为`field`，商品数量为`value`，恰好构成了购物车的3个要素。
- 存储对象：`hash`类型的`(key, field, value)`的结构与对象的`(对象id, 属性, 值)`的结构相似，也可以用来存储对象。

#### 常用命令

```
hset  [key]  [field] [value]    新建字段信息

hget  [key]  [field]    获取字段信息

hdel [key] [field]  删除字段

hlen  [key]   保存的字段个数

hgetall  [key]  获取指定key 字典里的所有字段和值 （字段信息过多,会导致慢查询 慎用：亲身经历 曾经用过这个这个指令导致线上服务故障）

hmset  [key]  [field1] [value1] [field2] [value2] ......   批量创建

hincr  [key] [field]   对字段值自增

hincrby [key] [field] [number] 对字段值增加number
```

### List

`Redis`中的`list`和`Java`中的`LinkedList`很像，底层都是一种链表结构， `list`的插入和删除操作非常快，时间复杂度为 0(1)
，不像数组结构插入、删除操作需要移动数据。

像归像，但是`redis`中的`list`底层可不是一个双向链表那么简单。

- 数据量较少：底层存储结构为一块连续内存，称之为`ziplist(压缩列表)`。将所有的元素紧挨着一起存储，分配的是一块连续的内存；
- 当数据量较多：将会变成`quicklist(快速链表)`结构。

可单纯的链表也是有缺陷的，链表的前后指针 `prev` 和 `next` 会占用较多的内存，会比较浪费空间，而且会加重内存的碎片化。**在redis
3.2之后就都改用`ziplist+链表`的混合结构，称之为 `quicklist(快速链表)`**。

### ziplist(压缩列表)

```c
struct ziplist<T>{
    int32 zlbytes;            //压缩列表占用字节数
    int32 zltail_offset;      //最后一个元素距离起始位置的偏移量,用于快速定位到最后一个节点
    int16 zllength;           //元素个数
    T[] entries;              //元素内容
    int8 zlend;               //结束位 0xFF
}
```

`int32 zlbytes`： 压缩列表占用字节数

`int32 zltail_offset`： 最后一个元素距离起始位置的偏移量,用于快速定位到最后一个节点

`int16 zllength`：元素个数

`T[] entries`：元素内容

`int8 zlend`：结束位 0xFF

压缩列表为了支持双向遍历，所以才会有 `ztail_offset` 这个字段，用来快速定位到最后一
个元素，然后倒着遍历。

![在这里插入图片描述](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518145912.png)

`**enerty数据结构**`

```c
struct entry{
    int<var> prevlen;             //前一个 entry 的长度
    int<var> encoding;            //元素类型编码
    optional byte[] content;      //元素内容
}
```

`entry`它的 `prevlen` 字段表示前一个 `entry` 的字节长度，当压缩列表倒着遍历时，需要通过这
个字段来快速定位到下一个元素的位置。

#### 应用场景

- 消息队列：`lpop`和`rpush`（或者反过来，`lpush`和`rpop`）能实现队列的功能
- 朋友圈的点赞列表、评论列表、排行榜：`lpush`命令和`lrange`命令能实现最新列表的功能，每次通过`lpush`
  命令往列表里插入新的元素，然后通过`lrange`命令读取最新的元素列表。

#### 常用命令

```
rpush  [key] [value1] [value2] ......    链表右侧插入

rpop    [key]  移除右侧列表头元素，并返回该元素

lpop   [key]    移除左侧列表头元素，并返回该元素

llen  [key]     返回该列表的元素个数

lrem [key] [count] [value]  删除列表中与value相等的元素，count是删除的个数。 count>0 表示从左侧开始查找，删除count个元素，count<0 表示从右侧开始查找，删除count个相同元素，count=0 表示删除全部相同的元素

(PS:   index 代表元素下标，index 可以为负数， index= 表示倒数第一个元素，同理 index=-2 表示倒数第二 个元素。)

lindex [key] [index]  获取list指定下标的元素 （需要遍历，时间复杂度为O(n)）

lrange [key]  [start_index] [end_index]   获取list 区间内的所有元素 （时间复杂度为 O（n））

ltrim  [key]  [start_index] [end_index]   保留区间内的元素，其他元素删除（时间复杂度为 O（n））
```

### set(集合)

`Redis` 中的 `set`和`Java`中的`HashSet` 有些类似，它内部的键值对是无序的、唯一 的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值
NULL。当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。

#### 应用场景

- 好友、关注、粉丝、感兴趣的人集合：
    1) `sinter`命令可以获得A和B两个用户的共同好友；
    2) `sismember`命令可以判断A是否是B的好友；
    3) `scard`命令可以获取好友数量；
    4) 关注时，`smove`命令可以将B从A的粉丝集合转移到A的好友集合
- 首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而`srandmember`命令则可以从中随机获取几个。
- 存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。

#### 常用命令

```
sadd  [key]  [value]  向指定key的set中添加元素

smembers [key]    获取指定key 集合中的所有元素

sismember [key] [value]   判断集合中是否存在某个value

scard [key]    获取集合的长度

spop  [key]   弹出一个元素

srem [key] [value]  删除指定元素
```

### zset(有序集合)

`zset`也叫`SortedSet`一方面它是个 `set` ，保证了内部 value 的唯一性，另方面它可以给每个 value 赋予一个`score`
，代表这个value的排序权重。它的内部实现用的是一种叫作`跳跃列表`的数据结构。

#### 应用场景

`zset` 可以用做排行榜，但是和`list`不同的是`zset`它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户
ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。

`zset` 还可以用来存储学生的成绩， `value` 值是学生的 ID, `score` 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。

#### 常用命令

```
zadd [key] [score] [value] 向指定key的集合中增加元素

zrange [key] [start_index] [end_index] 获取下标范围内的元素列表，按score 排序输出

zrevrange [key] [start_index] [end_index]  获取范围内的元素列表 ，按score排序 逆序输出

zcard [key]  获取集合列表的元素个数

zrank [key] [value]  获取元素再集合中的排名

zrangebyscore [key] [score1] [score2]  输出score范围内的元素列表

zrem [key] [value]  删除元素

zscore [key] [value] 获取元素的score
```

## 问答

Redis基础数据结构： **String**、**Hash**、**List**、**Set**、**SortedSet**、**HyperLogLog**、**Geo**、**Pub/Sub**

###### 大量的key需要设置同一时间过期

**Redis**可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在时间上加一个随机值，使得过期时间分散一些。

### Redis分布式锁

先用**setnx**争抢锁，抢到之后，再用**expire**给锁加一个过期时间防止锁忘记了释放。

###### 如果在setnx之后执行expire之前进程意外crash或者要重启维护了会怎么样？

这个锁就永远得不到释放了（set指令有非常复杂的参数，可以同时把**setnx**和**expire**合成一条指令使用）

###### 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

使用**keys**指令可以扫出指定模式的key列表。

###### 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

Redis的单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用**scan**
指令，**scan**指令可以无阻塞的提取出指定模式的key列表，但是会有一定地重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

###### Redis做异步队列么，你是怎么用的？

使用list结构作为队列，**rpush**生产消息，**lpop**消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

###### 能否不用sleep呢？

list还有个指令叫**blpop**，在没有消息的时候，它会阻塞住直到消息到来。

###### 能不能生产一次消费多次呢？

使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。

###### pub/sub有什么缺点？

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如**RocketMQ**等。

###### Redis如何实现延时队列？

使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用**zrangebyscore**指令获取N秒之前的数据轮询进行处理。

## Redis持久化

### 为什么需要持久化

- Redis 是内存数据库，宕机后数据会消失。
- Redis 重启后快速恢复数据，要提供持久化机制。

### 持久化方式

RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。

- RDB：**RDB** 持久化机制，是对 **Redis** 中的数据执行周期性的持久化。
- AOF：**AOF** 机制对每条写入命令作为日志，以 **append-only**
  的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的**binlog**。

#### RDB

将 Redis 某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为 dump.rdb，而在 Redis 服务器启动时，检查根目录是否有文件，有则重新加载
dump.rdb文件的数据到内存中。

##### 开启方式

- save 命令
  save 命令是一个同步操作。当客户端向服务器发送 save 命令请求进行持久化时，服务器会阻塞 save
  命令之后的其他客户端的请求，直到数据同步完成。如果数据量太大，同步数据会执行很久，这期间 Redis 服务器也无法接收其他请求，导致不可用。
- bgsave命令
  与 save 命令不同，bgsave 命令是一个异步操作。当客户端发出 bgsave 命令时，Redis 服务器主进程会 fork
  一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求，子进程会在数据保存到 rdb 文件后退出。

###### Redis如何解决要处理客户端的请求又要同时持久化？内存数据结构还在改变，会不会导致持久化的数据不一致啊？（RDB 持久化为什么叫快照持久化的原因）

Redis 使用的**操作系统的多进程 COW（Copy On Write）机制**来实现快照持久化，也就是RDB持久化方式。
使用操作系统的COW机制来进行数据段页面的分离，数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改，这时子进程相应的页面是没有变化的，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变。

###### 服务器配置定期自动触发

在 redis.conf 中配置: save 多少秒内 数据变了多少

```text
# save "" # 不使用RDB存储 不能主从
# save 900 1 # 表示15分钟(900秒钟)内至少1个键被更改则进行快照。
# save 300 10 # 表示5分钟(300秒)内至少10个键被更改则进行快照。
# save 60 10000 # 表示1分钟内至少10000个键被更改则进行快照。
```

通过配置文件触发持久化的方式与 bgsave 命令类似，达到触发条件时会 fork 一个子进程进行数据保存。
(线上的 Redis 环境不建议使用此方式。因为设置触发的时间太短，则容易频繁写入 rdb
文件，影响服务器性能，时间设置太长则会造成数据丢失。)

##### 流程

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/202208240929758.png)

1. Redis 父进程首先判断：当前是否在执行 save、bgsave 或 bgrewriteaof（aof 文件重写命令）的子进程，如果在执行则这次bgsave
   命令直接返回。（不能同时执行的原因是出于性能方面考虑，并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，对性能会产生影响。）
2. 父进程执行 fork（调用 OS 函数复制主进程）操作创建子进程，这个过程中父进程是非阻塞的，Redis 能执行来自客户端的其它命令。
3. 子进程创建 RDB 文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换。（RDB 始终完整）
4. 子进程发送信号给父进程表示完成，父进程更新统计信息。
5. 父进程 fork 子进程后，继续工作。

##### 文件结构

###### 大致结构

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/202208240931245.png)

- REDIS
  RDB 文件的开头部分是 REDIS 部分，这个部分长度为 5 个字节，保存着 “REDIS” 五个字符。通过这五个字符，程序在载入文件时，可以快速检查该文件是否是
  RDB 文件。
- db_version
  db_version 长度为 4 个字节，值是一个字符串表示的整数，这个整数记录的是 RDB 文件的版本号（不是 Redis 版本号），比如 "0006"
  就代表 RDB 文件的版本为第六版。
- databases
  一个 RDB 文件的 databases 部分可以保存任意多个非空数据库。

###### 完整结构

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/202208241032248.png)

- SELECTDB
  常量的长度为 1 个字节，当读入程序遇到这个值的时候，它知道接下来要读入的是一个数据库号码。
- db_number
  保存着一个数据库号码，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。
- key_value_pairs
  保存着数据库中所有键值对数据，如果键值对带有过期时间的话，那么键值对的过期时间也会保存在内。
- EOF
  结束标记
- check_sum
  校验和，检查文件是否损坏或者被修改

#### AOF

AOF（Append Only File）持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以 Redis 协议追加保存到以后缀为 aof
文件末尾，在 Redis 服务器重启时，会加载并运行 aof 文件的命令，以达到恢复数据的目的。

##### 开启方式

Redis 默认不开启 AOF 持久化方式，我们可以在 redis.conf 配置文件中开启并进行更加详细的配置。

```text
appendonly no  # 默认不开启，需要开启的话要改成yes。
appendfilename "appendonly.aof" # aof文件名
appenddirname "appendonlydir" # AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。# 
# appendfsync always #写入策略 always表示每执行一个命令就备份一次
appendfsync everysec #写入策略 每秒备份一次
# appendfsync no #写入策略 no表示将备份时机交给操作系统
no-appendfsync-on-rewrite no # 默认不重写aof文件 表示在对aof文件进行压缩时，是否执行同步操作
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

###### 突然机器掉电会怎样？

取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

###### RDB的原理是什么？

fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是**copy on write**
，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

###### Pipeline有什么好处，为什么要用pipeline？

可以将多次IO往返的时间缩减为一次，前提是**pipeline**执行的指令之间没有因果相关性。使用**redis-benchmark**
进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是**pipeline**批次指令的数目。

###### Redis的同步机制了解么？

Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次**bgsave**
，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

###### 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？

- **Redis Sentinal** 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
- **Redis Cluster** 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

### **Redis**的过期策略

定期删除：默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删

惰性删除：不主动删，等查询了看是否过期，过期就删了还不给你返回

###### 定期没删，也没查询？

redis内存淘汰机制：

1. **noeviction**：返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
2. **allkeys-lru**: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
3. **volatile-lru**: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
4. **allkeys-random**: 回收随机的键使得新添加的数据有空间存放。
5. **volatile-random**: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
6. **volatile-ttl**: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。

**LinkedHashMap**实现了LRU算法：
当容量超过100时，开始执行**LRU**策略：将最近最少未使用的 **TimeoutInfoHolder** 对象 **evict** 掉。

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518164118.webp)

## Redis集群

### 主从复制

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518165609.webp)

#### 原理

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518165643.webp)

1. 从数据库启动成功后，连接主数据库，发送 SYNC 命令
2. 主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令
3. 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令
4. 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照
5. 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令
6. 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令（从数据库初始化完成）
7. 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（从数据库初始化完成后的操作）
8. 出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制
9. 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis
   的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518165731.webp)

优点：

- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；
- 为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；
- Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力；
- Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求；
- Slave Server 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据

缺点：

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复（也就是要人工介入）；
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；
- 如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送sync 请求和主机全量同步，当多个
  Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。
- Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；

### Sentinel哨兵模式

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518165824.webp)

#### 原理

- 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器；
- 当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机

而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518165916.webp)

假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover
过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**
。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行
failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**
。这样对于客户端而言，一切都是透明的。

哨兵模式的工作方式：

- 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他Sentinel（哨兵）进程发送一个
  PING 命令。
- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被
  Sentinel（哨兵）进程标记为主观下线（SDOWN）
- 如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认
  Master 主服务器的确进入了主观下线状态
- 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN），
  则 Master 主服务器会被标记为客观下线（ODOWN）
- 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。
- 当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave
  从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
- 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向
  Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

优点：

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高(可以看作自动版的主从复制)。

缺点：

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

### Cluster 集群模式

Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在
redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 **Redis** 节点上存储不同的内容。如图每一个蓝色的圈都代表着一个
redis 的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点，对其进行存取和其他操作。

![](https://raw.githubusercontent.com/holdthebreath/picture-bed/master/20210518170051.webp)

#### 数据分片

Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽。
这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。如果我想移除节点 A
，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A
节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。

在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是
cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 CRC16 的算法得出一个结果，然后把结果对
16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

#### Redis 集群的主从复制模型

为了保证高可用，redis-cluster集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点
ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1
都宕机了，那么该集群就无法再提供服务了

#### 集群的特点

- 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
- 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
- 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。

