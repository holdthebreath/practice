### 数据结构

#### hash索引

##### 追加式更新数据库

更快写，查询慢，因此需要索引。
hash索引（key：键，value：文件偏移量）
避免用尽磁盘空间，对日志文件分解成一定大小的段，文件达到一定大小就关闭，后续写入新段文件，然后后台对段文件进行压缩。
删除键和关联的值使用一个标记，叫做墓碑，使合并压缩时丢弃所有值。
优点：

1. 追加/合并是顺序写，比随机写快很多。
2. 奔溃恢复简单，不用担心出现新旧混合的文件（更新文件则不行）
3. 合并旧段可以避免数据文件碎片化
   hash索引缺点：

- hash表必须全部放进内存，大量键情况性能咋搞。因为磁盘上维护hash会有大量随机io性能不佳，hash变满时继续增长代价昂贵，且冲突时需要复杂处理逻辑
- 区间查询效率低下，只能采用逐个查找

#### SSTables LSM-Tree

SSTables: key-value对的顺序按键排序

##### 优点：

- 合并段更加高效
- 在文件查找特定键，不需要在内存保存全部键的索引（更稀疏的hash）
- 读请求扫描请求范围多个k-v，可以考虑将这些记录保存到一个块并在写磁盘之前将其压缩，然后稀疏hash内存索引的每个条目指向压缩块的开头，节省磁盘空间，压缩还减少I/O带宽占用

##### 构建和维护：

- 写入时，将其添加到内存中的平衡树结构（红黑树），被成为内存表
- 内存表大于某个阈值，将其作为SSTables文件写入磁盘，由于树已经维护了按键排序的k-v对，写磁盘比较高效，新的SSTables文件成为数据库的最新部分。当SSTables写磁盘时，写入可以继续添加到一个新的内存表中
- 处理新请求首先尝试内存表中查找键，然后时最新磁盘段文件，然后时次新，以此类推
- 后台进程周期性执行段合并和压缩
- 在磁盘上单独保留日志，每个写入立刻追加到日志，避免崩溃恢复

基于合并和压缩排序文件原理的存储引擎通常被称为LSM存储引擎

#### B-Tree

B-Tree保留按键排序的k-v对，B-Tree将数据库分解成固定大小的块或页。页是内部读/写的最小单元，这种设计更接近底层硬件，因为磁盘也是固定大小的块排列。